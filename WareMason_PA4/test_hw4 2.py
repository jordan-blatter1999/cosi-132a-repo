#!/usr/bin/python3

# test_hw4.py
# Version 2.0.0
# 3/14/2022

import unittest

from inverted_index import InvertedIndex, get_raw_tf_value, cosine_sim, get_doc_vec_norm, parse_query, top_k_docs
from text_processing import TextProcessing

text_processor = TextProcessing()


class TestInvertedIndex(unittest.TestCase):
    """Tests for the inverted index. This class tests the Inverted Indecx data 
    structure as well as the intersection method in inverted_index.py."""
    def setUp(self) -> None:
        self.sample_document = {
            'id': 1,
            'title': 'sample title',
            'author': 'john doe',
            'published_date': '12-34-56',
            'content_str': 'sample body'
        }
        self.sample_document1 = {
            'id': 1,
            'title': 'filler',
            'author': 'john doe',
            'published_date': '12-34-56',
            'content_str': 'filler'
        }
        self.sample_document2 = {
            'id': 1,
            'title': 'filler',
            'author': 'john doe',
            'published_date': '12-34-56',
            'content_str': 'filler'
        }
        return super().setUp()

    def test_index_document(self):
        """A document is indexed into the appearances dictionary correctly."""
        invidx = InvertedIndex()
        invidx.index_document(self.sample_document)
        message = 'Inverted Index DS does not load appearances dict correctly'
        self.assertDictEqual(invidx.appearances_dict, {'bodi': {(1, 1.0)}, 'titl': {(1, 1.0)}, 'sampl': {(1, 2.0)}}, message)

    def test_load_postings_list(self):
        """The postings list generated by the Inverted Index DS is correct."""
        invidx = InvertedIndex()
        invidx.index_document(self.sample_document)
        invidx.load_index_postings_list()
        message = 'Inverted Index DS does not load appearances dict correctly'
        self.assertCountEqual(invidx.index, [{'token': 'sampl', 'doc_tf_index': [(1, 2.0)]},
                                             {'token': 'titl', 'doc_tf_index': [(1, 1.0)]},
                                             {'token': 'bodi', 'doc_tf_index': [(1, 1.0)]}], message)
        
    def test_get_raw_tf_value(self):
        """The correct raw term frequency score is calculated correctly for a term in a document"""
        term = 'bodi'
        content = ' '.join(text_processor.get_normalized_tokens(self.sample_document['content_str']))
        raw_tf = get_raw_tf_value(term, content)
        message = 'The raw term frequency is not calculated properly'
        self.assertEqual(1.0, raw_tf, message)
        
    def test_cosine_sim(self):
        """The cosine similarity between a query vector and a document vector is calculated correctly."""
        term = 'bodi'
        invidx = InvertedIndex()
        invidx.index_document(self.sample_document)
        invidx.index_document(self.sample_document1)
        invidx.index_document(self.sample_document2)
        invidx.load_index_postings_list()
        term_tf_score = get_raw_tf_value(term, ' '.join(text_processor.get_normalized_tokens(self.sample_document['content_str'])))
        term_tf_idf_score = (term_tf_score * text_processor.idf(3, 1))
        doc_score = cosine_sim(tfidf_term=term_tf_idf_score,
                                        tf_doc=term_tf_score,
                                        query_length=1,
                                        doc_length=get_doc_vec_norm([2.0, 1.0, 1.0]))
        message = 'The cosine similarity of a query vecotr to a document vecotr is computed incorrectly'
        self.assertGreaterEqual(doc_score, 3.1699, message)
        
    def test_get_doc_vec_norm(self):
        """The cosine-normed length of a document given its terms tf values is calculated properly."""
        message = 'The cosine-normed length of a document is calculated properly'
        self.assertEqual(get_doc_vec_norm([2.0, 1.0, 1.0]), 0.5, message)
        
    def test_parse_query(self):
        """A query is parse properly."""
        query = 'my mind, body, and soul.'
        resulting_query = parse_query(query)
        message = 'A query is not parsed correctly'
        self.assertEqual(resulting_query, (['mind', 'bodi', 'soul'], {'and', 'my'}, set()), message)
        
    def test_top_k_docs(self):
        """The top k docs are retrieved propperly from a heap."""
        doc_scores = {
            1: 1.0,
            2: 2.0,
            3: 3.0,
            4: 4.0,
            5: 5.0,
            6: 6.0
        }
        results = top_k_docs(doc_scores, 3)
        template = [(6, 6.0), (5, 5.0), (4, 4.0)]
        message = 'The top k docs are not extracted properly.'
        self.assertEqual(results, template, message)
        

class TestTextProcessing(unittest.TestCase):
    """Tests for the text processing done in text_processing.py."""
    def test_normalize_token(self):
        """A token is normalized correctly."""
        tp = TextProcessing()
        sample_token = 'sample'
        normalized_sample_token = tp.normalize(sample_token)
        message = 'The token: \'sample\' was not normalzied correctly'
        self.assertEqual(normalized_sample_token, 'sampl', message)

    def test_normalize_strings(self):
        """Multiple strings simulating a title and content are normalized correctly"""
        tp = TextProcessing()
        normalized_strings = tp.get_normalized_tokens('sample title', 'sample body')
        message = 'Multiple strings were not notmalized correctly'
        self.assertEqual(set(normalized_strings), {'bodi', 'titl', 'sampl'}, message)




if __name__ == '__main__':
    unittest.main()
